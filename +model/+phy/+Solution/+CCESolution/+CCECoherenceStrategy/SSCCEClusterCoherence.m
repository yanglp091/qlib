classdef SSCCEClusterCoherence < model.phy.Solution.CCESolution.CCECoherenceStrategy.AbstractClusterCoherence
    %ECCECLUSTERCOHERENCE 
                %calculate the coherence of single cluster for single sample CCE 
    properties
      bath_spin_state
    end
    
    methods
        function obj=SSCCEClusterCoherence(cluster_spin_index,cluster_parameters)
            obj@model.phy.Solution.CCESolution.CCECoherenceStrategy.AbstractClusterCoherence();
            if nargin >0
               obj.generate(cluster_spin_index,cluster_parameters);
               obj.bath_spin_state=cluster_parameters.bath_spin_state;
            end                    
        end
        
        function coh=calculate_cluster_coherence(obj,evolution_para,varargin)
            obj.npulse=evolution_para.npulse;
            center_spin_states=evolution_para.center_spin_states;
            is_secular=evolution_para.is_secular;
            obj.timelist=evolution_para.timelist;
            
            %set the local field generated by the bath spins outside of the cluster
            obj.set_local_field;
            
            %generate the spin_collection for this cluster including the central spin
            obj.spin_collection= model.phy.SpinCollection.SpinCollection();
            obj.spin_collection.spin_source=model.phy.SpinCollection.Strategy.FromSpinList([{obj.center_spin},obj.cluster_bath_spin]);
            obj.spin_collection.generate();
             
            hamiCell=obj.gen_reduced_hamiltonian(center_spin_states,is_secular);
            [h_list,hami_prefactor]=obj.gen_hami_list(hamiCell);
            
            %generate a SpinCollection of bath spins in this cluster
            bath_cluster_sc= model.phy.SpinCollection.SpinCollection();
            bath_cluster_sc.spin_source=model.phy.SpinCollection.Strategy.FromSpinList(obj.cluster_bath_spin);
            bath_cluster_sc.generate();
            
            %Observable
            obs=model.phy.QuantumOperator.SpinOperator.Observable(bath_cluster_sc,'IdentityMatrix');
            obs.setMatrix(1);
            
            % wave function vector
            state_idxs=obj.bath_spin_state(obj.cluster_spin_index);
            wave_function=1;
            for kk=1:length(state_idxs)
                state_kk=obj.cluster_bath_spin{kk}.eigen_vect(:, state_idxs(kk));
                wave_function=kron(wave_function,state_kk);
            end
            
            coh=obj.calculate_coherence_hilbert(h_list,hami_prefactor,obs,wave_function,'PureState');
            obj.reset_local_field;
        end
        
        function reset_local_field(obj)
            for kk=1:length(obj.cluster_bath_spin);
                obj.cluster_bath_spin{kk}.local_field=[0,0,0];
            end
        end
        function set_local_field(obj)
            cluster_index=obj.cluster_spin_index;
            tot_bath_spin_num=obj.bath_spin_collection.getLength;% get the number of the total bath spin 
            tot_bath_spin_index=1:tot_bath_spin_num;
            ex_cluster_index=setdiff(tot_bath_spin_index,cluster_index);
            
            for kk=1:length(cluster_index)
               local_field=[0,0,0];
               target_spin=obj.cluster_bath_spin{kk};
               for ii=1:length(ex_cluster_index)
                   os_idx=ex_cluster_index(ii);% the index of the spin outside of the cluster
                   outside_spin=obj.bath_spin_collection.spin_list{os_idx};                   
                   local_field2add=obj.calculate_dipolar_field(target_spin,outside_spin,os_idx);
                   local_field=local_field+local_field2add;
               end
               obj.cluster_bath_spin{kk}.local_field=local_field;
            end
            
        end
        function lf2add=calculate_dipolar_field(obj,spin1,spin2,os_idx)
%             pair_sc= model.phy.SpinCollection.SpinCollection();
%             pair_sc.spin_source=model.phy.SpinCollection.Strategy.FromSpinList([{spin1},{spin2}]);
%             pair_sc.generate();
            
%             dip_interaction=model.phy.SpinInteraction.DipolarInteraction(pair_sc);
%             coeff=dip_interaction.calculate_coeff([{tar_spin},{out_spin}]);
            coeff=calculate_dip_coeff(spin1,spin2);
            
            state_idx=obj.bath_spin_state(os_idx);
            eig_vec=spin2.eigen_vect(:,state_idx);
            sx_val=eig_vec'*spin2.sx*eig_vec;
            sy_val=eig_vec'*spin2.sy*eig_vec;
            sz_val=eig_vec'*spin2.sz*eig_vec;
            s_vec=[sx_val,sy_val,sz_val];

            lf2add=-s_vec*coeff/spin1.gamma;
        end
                       
    end
    
end

function coeff=calculate_dip_coeff(spin1,spin2)        
    coord1=spin1.coordinate; gamma1=spin1.gamma;
    coord2=spin2.coordinate; gamma2=spin2.gamma;

    vect=coord2-coord1;
    distance=norm(vect);
    ort=vect/distance;

    % dipolar interaction strength
    A=hbar*mu0*gamma1*gamma2/(4*pi*(distance*1e-10)^3);

    % the dipolar coupling matrix
    coeff=A*...
        [1-3*ort(1)*ort(1)   -3*ort(1)*ort(2)   -3*ort(1)*ort(3);
          -3*ort(2)*ort(1)  1-3*ort(2)*ort(2)   -3*ort(2)*ort(3);
          -3*ort(3)*ort(1)   -3*ort(3)*ort(2)  1-3*ort(3)*ort(3)];
    
end

